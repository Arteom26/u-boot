/**
  ******************************************************************************
  * @file    /WB_SerialNAND_Sample_Code_LLD.c
  * @author  Winbond FAE Steam Lin
  * @version V1.0.9
  * @date    9-March-2016
  * @brief   This code provide the low level hardware initial and basic Serial operate function based on STM32F205.
  *
  * COPYRIGHT 2015 Winbond.
*/
#include <common.h>
#include <spi.h>
#include <malloc.h>
#include <asm/io.h>
#include <command.h>
#include <linux/mtd/rawnand.h>
#include <generated/timestamp_autogenerated.h>

#define REG_HCLKEN      0xB0000210
#define REG_PCLKEN1     0xB000021C
#define REG_MFP_GPD_L	0xB0000088
#define SPI_BASE       0xB0060000 //QSPI0
#define SPI_CTL        (SPI_BASE + 0x00)
#define SPI_CLKDIV     (SPI_BASE + 0x04)
#define SPI_SSCTL      (SPI_BASE + 0x08)
#define SPI_PDMACTL    (SPI_BASE + 0x0C)
#define SPI_FIFOCTL    (SPI_BASE + 0x10)
#define SPI_STATUS     (SPI_BASE + 0x14)
#define SPI_TX         (SPI_BASE + 0x20)
#define SPI_RX         (SPI_BASE + 0x30)

/* spi register bit */
#define ENINT           (0x01 << 17)
#define TXNEG           (0x01 << 2)
#define RXNEG           (0x01 << 1)
#define LSB             (0x01 << 13)
#define SELECTLEV       (0x01 << 2)
#define SELECTPOL       (0x01 << 3)
#define SELECTSLAVE0    0x01
#define SELECTSLAVE1    0x02
#define SPIEN           0x01
#define SPIENSTS        (0x01 << 15)
#define TXRXRST         (0x01 << 23)
#define SPI_BUSY        0x00000001
#define SPI_SS_ACT      0x00000001
#define SPI_SS_HIGH     0x00000004
#define SSCR_AUTOSS_Msk (1 << 3)
#define SSCR_SS_LVL_Msk (1 << 2)

static struct nand_chip nand_chip[CONFIG_SYS_MAX_NAND_DEVICE];

/********************
Function: CS select low
Argument:
return:
*********************/
static void WB_CS_LOW(void)
{
	// /CS: active
	writel((readl(SPI_SSCTL) & ~(SSCR_AUTOSS_Msk|SSCR_SS_LVL_Msk))| SPI_SS_ACT, SPI_SSCTL);
}

/********************
Function: CS select high
Argument:
return:
*********************/
static void WB_CS_HIGH(void)
{
	// /CS: de-active
	writel(readl(SPI_SSCTL) & ~(SSCR_AUTOSS_Msk|SSCR_SS_LVL_Msk|SPI_SS_ACT), SPI_SSCTL);
}

/********************
Function: SPI hardware command send
Argument: DI: DI data
return: DO data
*********************/
static uint8_t SPIin(uint8_t DI)
{
	writel(DI, SPI_TX);
	while ((readl(SPI_STATUS) & 0x100)); //RXEMPTY
	return ((unsigned char)readl(SPI_RX) & 0xff);
}

/********************
Function: SPI NAND Ready busy check
Argument:
return:
*********************/
static void WB_Serial_NAND_ReadyBusy_Check(void)
{
	uint8_t SR = 0xFF;
	//while((SR & 0x3) != 0x00){ CWWeng
	while((SR & 0x1) != 0x00) {
		WB_CS_LOW();
		//SPIin(0x05); Winbond only
		SPIin(0x0F); //CWWeng : for all
		SPIin(0xC0);
		SR = SPIin(0x00);
		WB_CS_HIGH();
	}
	return;
}

/********************
Function: SPINAND page data read
Argument:
PA_H, page address
PA_L, page address
return:
*********************/
static void WB_Serial_NAND_PageDataRead(uint8_t addr2, uint8_t addr1, uint8_t addr0)
{
	WB_CS_LOW();
	SPIin(0x13); //
	SPIin(addr2); // Page address
	SPIin(addr1); // Page address
	SPIin(addr0); // Page address
	WB_CS_HIGH();
	WB_Serial_NAND_ReadyBusy_Check(); // Need to wait for the data transfer.
	return;
}

/********************
Function: Serial NAND Status register read
Argument:
sr_sel: select register
return: status register value
*********************/
uint8_t WB_Read_Serial_NAND_StatusRegister(uint8_t sr_sel)
{
	uint8_t SR = 0;  // status register data
	switch(sr_sel) {
	case 0x01:
		WB_CS_LOW();
		//SPIin(0x05); CWWeng : Winbond only
		SPIin(0x0F); //CWWeng : for all
		SPIin(0xA0); // SR1
		SR = SPIin(0x00);
		WB_CS_HIGH();
		break;
	case 0x02:
		WB_CS_LOW();
		//SPIin(0x05); CWWeng : Winbond only
		SPIin(0x0F); //CWWeng : for all
		SPIin(0xB0); // SR2
		SR = SPIin(0x00);
		WB_CS_HIGH();
		break;
	case 0x03:
		WB_CS_LOW();
		//SPIin(0x05); CWWeng : Winbond only
		SPIin(0x0F); //CWWeng : for all
		SPIin(0xC0); // SR3
		SR = SPIin(0x00);
		WB_CS_HIGH();
		break;
	default:
		SR = 0xFF;
		break;
	}
	return SR;
}

/********************
Function: Serial NAND Normal read to buffer
Argument:
addh~addl: Read data address
count: read count
return:
*********************/
static void WB_Serial_NAND_Normal_Read(uint8_t addh, uint8_t addl, uint8_t* buff, uint32_t count)
{
	uint32_t i = 0;
	WB_CS_LOW();
	SPIin(0x03);
#ifdef	CONFIG_SPI_NAND_GD
	SPIin(0x00); // dummy
#endif
	SPIin(addh);
	SPIin(addl);
#ifndef	CONFIG_SPI_NAND_GD
	SPIin(0x00); // dummy
#endif
	for( i = 0; i < count; i++) {
		*(buff+i) = SPIin(0x00);
	}
	WB_CS_HIGH();
	return;
}

/********************\
Function: Serial NAND Bad block mark check
Argument:
return:
1: Check block is bad block.
0: Check block is not bad block.
update: V.1.0.8 // correct the bad block mark address
*********************/
static uint8_t WB_Serial_NAND_bad_block_check(uint32_t page_address, uint32_t page_size)
{
	uint8_t read_buf;
	//uint8_t EPR_status;
	WB_Serial_NAND_PageDataRead((page_address >> 16) & 0xFF,
				    (page_address >> 8) & 0xFF,
				     page_address & 0xFF);    // Read the first page of a block

	/* if build-in ECC algorithm enable
	EPR_status = WB_Check_Embedded_ECC_Flag();
	if(EPR_status > 1){
	  return 1;															// Check ECC status and return fail if (ECC-1, ECC0) = (1,0) or (1, 1)
		  }
	*/
#ifdef CONFIG_SPI_NAND_MICRON
	WB_Serial_NAND_Normal_Read((page_size >> 8) | (page_address & (1 << 6) ? (1 << 4) : 0), 0x0, &read_buf, 1);
#else
	WB_Serial_NAND_Normal_Read((page_size >> 8), 0x0, &read_buf, 1);	// Read bad block mark at 0x800 update at v.1.0.8
#endif
	if(read_buf != 0xFF) {	// update at v.1.0.7
		return 1;
	}
	WB_Serial_NAND_PageDataRead(((page_address + 1) >> 16) & 0xFF,
				    ((page_address + 1) >> 8) & 0xFF,
				     (page_address+1) & 0xFF);	// Read the second page of a block

	/* if build-in ECC algorithm enable
	EPR_status = WB_Check_Embedded_ECC_Flag();
	if(EPR_status > 1){
	  return 1;															// Check ECC status and return fail if (ECC-1, ECC0) = (1,0) or (1, 1)
		  }
	*/
#ifdef CONFIG_SPI_NAND_MICRON
	WB_Serial_NAND_Normal_Read((page_size >> 8) | ((page_address+1) & (1 << 6) ? (1 << 4) : 0), 0x0, &read_buf, 1);
#else
	WB_Serial_NAND_Normal_Read((page_size >> 8), 0x0, &read_buf, 1);	// Read bad block mark at 0x800 update at v.1.0.8
#endif
	if(read_buf != 0xFF) {	// update at v.1.0.7
		return 1;
	}
	return 0;
}

/********************
Function: Check ECC-E status
Argument:
Comment: Change function name at V1.0.3
*********************/
uint8_t WB_Check_Embedded_ECC_Enable(void)
{
	uint8_t SR;
	SR = WB_Read_Serial_NAND_StatusRegister(2);  // Read status register 2
	return (SR&0x10)>>4;
}

/********************
Function: Check ECC-1, ECC-0 status
Argument:
Comment: Add this function at V1.0.3
*********************/
uint8_t WB_Check_Embedded_ECC_Flag(void)
{
	uint8_t SR;
	SR = WB_Read_Serial_NAND_StatusRegister(3); 	// Read status register 3
	return (SR&0x30)>>4;				// Check ECC-1, ECC0 bit
}

/********************
Function: Serial NAND reset command
Argument:
return:
*********************/
static void WB_NAND_Reset(void)
{
	WB_CS_LOW();
	SPIin(0xFF);
	WB_CS_HIGH();
	WB_Serial_NAND_ReadyBusy_Check();
}

static void nuc980_spi_init(void)
{

	writel(readl(REG_PCLKEN1) | 0x10, REG_PCLKEN1);       // QSPI0 clk
	writel(readl(REG_MFP_GPD_L) | 0x00111100, REG_MFP_GPD_L); //QSPI0: D2, D3, D4, D5

	writel(0, SPI_SSCTL); /* AUTOSS=0; low-active; de-select all SS pins. */
	writel((readl(SPI_CTL) & ~0x1F00) | 0x800, SPI_CTL); //Data Width = 8 bit
	writel(4, SPI_CLKDIV); //150/5 = 30 MHz

	writel(readl(SPI_FIFOCTL) | 0x3, SPI_FIFOCTL); //TX/RX reset
	while ((readl(SPI_STATUS) & TXRXRST));

	writel((readl(SPI_CTL) & ~0xFF)|5, SPI_CTL);

	writel(readl(SPI_CTL) | SPIEN, SPI_CTL);
	while ((readl(SPI_STATUS) & SPIENSTS) == 0);

	WB_NAND_Reset();
}

int spinand_is_bad_block(struct mtd_info *mtd, int block)
{
	int page_addr = 0 + block * (mtd->erasesize / mtd->writesize);

	if (WB_Serial_NAND_bad_block_check(page_addr, mtd->writesize))
		return 1;
	return 0;

}

/* for reading page size from SPI NAND header, offset 0x10 */
int spinand_read_first_256byte(struct mtd_info *mtd, uchar *dst)
{

	WB_Serial_NAND_PageDataRead(0, 0, 0);
#ifdef CONFIG_SPI_NAND_MICRON
	WB_Serial_NAND_Normal_Read(real_page & (1 << 6) ? (1 << 4) : 0, 0, dst, 256);
#else
	WB_Serial_NAND_Normal_Read(0, 0, dst, 256);
#endif
	return 0;
}

int spinand_read_page(struct mtd_info *mtd, int block, int page, uchar *dst)
{
	int real_page;

	real_page = block * (mtd->erasesize / mtd->writesize) + page;

	WB_Serial_NAND_PageDataRead((real_page >> 16) & 0xFF, (real_page >> 8) & 0xFF, real_page & 0xFF);
#ifdef CONFIG_SPI_NAND_MICRON
	WB_Serial_NAND_Normal_Read(real_page & (1 << 6) ? (1 << 4) : 0, 0, dst, mtd->writesize);
#else
	WB_Serial_NAND_Normal_Read(0, 0, dst, mtd->writesize);
#endif
	return 0;
}

int nand_spl_load_image(uint32_t offs, unsigned int uboot_size, void *vdst)
{
	struct nand_chip *nand = &nand_chip[0];
	struct mtd_info *mtd = nand_to_mtd(nand);

	unsigned int block, lastblock;
	unsigned int page;
	unsigned int page_count = mtd->erasesize / mtd->writesize;

	/*
	 * offs has to be aligned to a page address!
	 */
	block = offs / mtd->erasesize;
	lastblock = (offs + uboot_size - 1) / mtd->erasesize;
	page = (offs % mtd->erasesize) / mtd->writesize;

	while (block <= lastblock) {
		if (!spinand_is_bad_block(mtd, block)) {
			/*
			 * Skip bad blocks
			 */
			while (page < page_count) {
				spinand_read_page(mtd, block, page, vdst);
				vdst += mtd->writesize;
				page++;
			}

			page = 0;
		} else {
			lastblock++;
		}

		block++;
	}

	return 0;
}

unsigned int nand_page_size(void)
{
	return CONFIG_SYS_NAND_PAGE_SIZE;
}

void nand_init(void)
{
	struct nand_chip *nand = &nand_chip[0];
	struct mtd_info *mtd = nand_to_mtd(nand);
	int maxchips = CONFIG_SYS_NAND_MAX_CHIPS;

	if (maxchips < 1)
		maxchips = 1;

	nuc980_spi_init();

	/* Read page size from SPI NAND Flash header */
	spinand_read_first_256byte(mtd, (uchar *)0xE00000);

	mtd->writesize = *(unsigned int*)0xE00010 & 0xFFFF;
	mtd->erasesize = 64 * (mtd->writesize);
	printf("Page size: 0x%x, OOB size: 0x%x\n", mtd->writesize, *(unsigned int*)0xE00010 >> 16);
}

void nand_deselect(void)
{

}
